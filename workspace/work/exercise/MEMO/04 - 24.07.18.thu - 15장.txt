15장(24.07.17) [ 이중포인터와 배열포인터 ]


Title : To
===========================================

char* a[] ;
char* [] a ;
char*  * p ;

ina a[3][4] ;
int [4] aa[3];
int[4] []aa;
int  *pp[4];
int (8) 








Title : To function pointer 함수포인터
============================================

	p=a;
	p[1] = 11;
	a[1] ==11;
	
	p=f;
	p();
	
	p = a; 
	
	
	
	void func(void);
	
	type id;
	
	void(void)	func
	
	
	int func2(int,float);
	
	int(int,float) func2;
	
	int(int,float) * pf ;
	
	int 	* pf (int,float);	//pf = func ?
	->
	int    (* pf)(int,float); 	//pf = func ;
	
	함수의 타입
	-> (int   (*)(int, float) )	 pf;
	
	
	pf =  func ;
	pf = &func ;
	
	
	
	
-------------------------------
	int (*)(int,int) fp;	//표준식
	int (*)(int,int) fp[];	//표준식
	
	int (*fp[]) (int,int) = [0,add,sub, ...}; //표현식
	
	
	
Title: void 포인터
==============================================

	int * pi;
	int * pc;
	
	pi+1
	pc+1
		
	sizeof(void) ==0 //1
	
	
	
	void * : type 이 된다. 
	void *	pv;
	


Title : To p
==================================================
{
	int a[]={10,1,2,3,4,5,6,7,8,9};
	
	int *p;
	p =a;
	
	printf("%d",a); // : 1000
	
	printf("%d", *	 p++ ); //10, p == 1004 
	
	operator++
		1. copy itself to backup.
		2. ++
		3. return backup
		
	printf("%d", *(p++) );	// 1/1008

	printf("%d", (*p)++ ); //  == (*p)=(*p)+1    --> 2+1 이라 3이됨. 
	printf("%d", ++*p ); //	   	2(=4),1008			
	printf("%d", *++p ); //		3,1008
}

	
	