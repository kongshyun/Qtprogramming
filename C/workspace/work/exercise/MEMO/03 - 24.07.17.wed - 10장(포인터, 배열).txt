10장 배열과 포인터

*(a+0) == a[0]

(a+2) == &a[2]

위 표현 익숙해지기

EX)
	for(i=0l i<3;i++)
	{
		printf ("%d\m",*(array+i));
	}
		--> array[i]를 프린트함.
		


Title : To pointer to array
=========================================

{
	int i=123;
	int *pi;
	pi = &i ; //o	(int*) = (int *const)
	
	
{
	int a[]={10,1,2};
	int a[3]; //표현식
	int[3] a; //표준식
	
	int[] a;
	
	int *p;
	
	int[] a;와 int * p; 둘다 1차원 이므로 p=a가능	
	
	------> p=a; //o
	*p == p[0];  //o
	a[0] == *a ; //o
	
	p[0]=100;
	p[1]=102;
	p[2]=101;을 하면   --> a[3]={100,102,101}	
}

int ary[3];
int *pa =ary;
sizeof(ary); //12바이트, 배열 전체 크기
sizeof(pa); //4바이트, 포인터 하나 크기

ary=ary+1
ary++       -> 안됨. 포인터는됨.


Title: To array
======================================

	int a[] = {10  ,1  ,2  ,3  ,4  };
			   @100
	printf("%d", a); // 100
	printf("%d", a+1); //	104 (다음 배열 이라는 뜻.  a+1 == & a[1]
	
	a+1 == (int *) + (int) ==> int* + int*
	--> int는 4바이트이고, int*는 8바이트이므로 더 큰것에 맞춘다.
			  
			32비트 시스템   -> sizeof (int): 4B, sizeof(int*) : 4B
			
			64비트 시스템   -> sizeof (int): 4B, sizeof(int*) : 8B
			
	int aa [2][4] = {10,1,2,3,   4,5,6,7};
				 = {
						{10,1,2,3},
						{4,5,6,7 }
					}
		printf("%d",aa); // 100
		printf("%d",aa+1 == & aa[1]); // 100
		printf("%d",aa[1]); // 116
	
-------------------------------------------------------------

 xx/0717_2.c

1차원배열을 포인터로 만들었는데, 2차원 배열은 어떻게 포인터로 바꾸는가?
   -> 2차원 배열을 1차원 배열 형태로 바꾼다.
   
   int aa[2][3];    //3개짜리가 2개있는거임.
   int [3] 
   
   - 3차원 배열을 바꿔보자.      
   int aa[2][3][4];
   int [3][4] aa[2];
   int     (* ppp) [3][4];
   
   
   
   
-----------------------------------------------------------------




